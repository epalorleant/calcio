# OpenShift/Kubernetes Deployment Guide

## Database Migrations with Alembic

This deployment uses **Alembic** for database schema management, which is well-suited for OpenShift/Kubernetes deployments.

### Why Alembic is Suitable for OpenShift

✅ **Idempotent**: Running migrations multiple times is safe (Alembic tracks applied migrations)  
✅ **Version Control**: All schema changes are tracked in code  
✅ **Rollback Support**: Can downgrade migrations if needed  
✅ **Container-Friendly**: Runs as a one-time job or init container  
✅ **Production-Ready**: Used by many production applications  

### Migration Strategy

We use an **Init Container** approach for database migrations:

The init container runs migrations **before** the main application starts. This ensures:
- Migrations always run before the app
- App won't start if migrations fail
- Simple deployment (single Deployment)
- Automatic migration execution on every deployment

See: `backend-with-init.yaml`

### Deployment Steps

1. **Deploy the backend with migrations**:
   ```bash
   kubectl apply -f infra/k8s/backend-with-init.yaml
   ```

2. The init container will:
   - Convert async URL to sync for Alembic
   - Run `alembic upgrade head`
   - Only proceed if migrations succeed

3. The main container uses the async URL for the application

### Database URL Configuration

The secret contains two URLs:
- `DATABASE_URL`: Sync URL (postgresql://) for Alembic
- `DATABASE_URL_ASYNC`: Async URL (postgresql+asyncpg://) for the application

Alembic requires a sync driver (psycopg2), while the FastAPI app uses async (asyncpg).

### Creating New Migrations

1. **Develop locally**:
   ```bash
   cd backend
   alembic revision --autogenerate -m "Description"
   ```

2. **Review the migration** in `alembic/versions/`

3. **Test locally**:
   ```bash
   alembic upgrade head
   ```

4. **Commit and deploy**: The migration will run automatically on next deployment

### Troubleshooting

#### Migration Fails

1. Check migration logs:
   ```bash
   kubectl logs deployment/backend -c migration -n calcio
   ```

2. Check database connectivity:
   ```bash
   kubectl exec -it deployment/backend -n calcio -- \
     alembic current
   ```

#### Migration Already Applied

Alembic tracks applied migrations in the `alembic_version` table. If a migration is already applied, Alembic will skip it automatically.

#### Rollback

To rollback a migration:
```bash
kubectl exec -it deployment/backend -c migration -n calcio -- \
  alembic downgrade -1
```

### Best Practices

1. **Always test migrations locally** before deploying
2. **Review autogenerated migrations** - Alembic can miss some changes
3. **Use descriptive migration messages**: `alembic revision -m "Add player_stats table"`
4. **Never edit applied migrations** - create new ones instead
5. **Backup database** before major migrations in production
6. **Use init containers** for automatic migration on deployment

### Security Considerations

- Migrations run with minimal privileges (non-root, dropped capabilities)
- Database credentials stored in Kubernetes Secrets
- Migration container has resource limits to prevent resource exhaustion

### Alternative: Helm Chart

For more complex deployments, consider creating a Helm chart that:
- Manages migration jobs
- Handles rollbacks
- Provides hooks for pre/post migration tasks

### Monitoring

Monitor migration status:
```bash
# Check init container status
kubectl describe pod <pod-name> -n calcio

# Check if init container completed
kubectl get pods -n calcio -l app=backend
```

### Production Checklist

- [ ] Database backups configured
- [ ] Migration rollback plan documented
- [ ] Resource limits set for migration container
- [ ] Monitoring/alerting for migration failures
- [ ] Database URL secrets properly configured
- [ ] Tested migration process in staging

